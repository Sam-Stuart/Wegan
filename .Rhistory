Rserve()(
)
library(Rserve)
Rserve()
q()
library("ggplot2") # For PCA plot
library("WGCNA") # For network analysis
library("DESeq2") # For data transformation
install.packages("DESeq2")
BiocManager::install("DESeq2")
BiocManager::install("DESeq2")
library("DESeq2") # For data transformation
require(DESeq2)
# Allow multi-threading within WGCNA:
# This function detects the number of threads available and helps speed up certain calculations.
enableWGCNAThreads()
library("ggplot2") # For PCA plot
library("WGCNA") # For network analysis
library("DESeq2") # For data transformation
# Allow multi-threading within WGCNA:
# This function detects the number of threads available and helps speed up certain calculations.
enableWGCNAThreads()
?enableWGCNAThreads
# Allow multi-threading within WGCNA:
# This function detects the number of threads available and helps speed up certain calculations.
WGCNA::enableWGCNAThreads()
# Allow multi-threading within WGCNA:
# This function detects the number of threads available and helps speed up certain calculations.
enableWGCNAThreads()
library("WGCNA") # For network analysis
install.packages(‘GO.db’)
install.packages('Go.db')
BiocManager::install('GO.db')
library(GO.db)
require(GO.db)
# Allow multi-threading within WGCNA:
# This function detects the number of threads available and helps speed up certain calculations.
enableWGCNAThreads()
library("WGCNA") # For network analysis
# Allow multi-threading within WGCNA:
# This function detects the number of threads available and helps speed up certain calculations.
enableWGCNAThreads()
# Allow multi-threading within WGCNA:
# This function detects the number of threads available and helps speed up certain calculations.
WGCNA::enableWGCNAThreads()
options(stringsAsFactors=FALSE) # Required for WGCNA.
setwd('WORKING_DIRECTORY_PATH')
getwd()
counts_raw <- read.csv(file="counts_data_file.csv", header=TRUE, row.names = 1)
library(xcms)
library(MSnbase) ## readSRMData() function
library(msdata)
library(pracma)
library(readxl)
source("./lc-autofit-script/util-origin.R")  ## Use a relative path [davidzhao]
setwd("~/lc-autofit")
source("./lc-autofit-script/util-origin.R")  ## Use a relative path [davidzhao]
# Determine the cutoff value that will affect the peak selection in
# xcms xset. Lower the more peaks will be selected
OFFSET <- 0.8   ## This variable is not called in following scripts?!
base_file_name <- "KIT2-0-5404_1031350968_26_0_1_1_18_20000617-1031350968_1_1_18_20000617.mzML"
with_dir <- glue::glue("./lc-autofit-script/mzML/{base_file_name}") ## Modify the path
ms <- MSnbase::readSRMData(files = with_dir) ## Add a namespace
# 3 ways to find the peak: 1) "simple" (e.g. highest peak), 2) "xcms", and 3) "gc-auto_fit"
# 4 ways to calculate the peak area: 1) "simple" (e.g. peak_middle * peak_range);
# 2) "step"; 3) "trapz"; and 4) "gc-auto_fit"
# Choose the degree of smooth
# Benchmark through the mean absolute error (MAE)
smooth <- FALSE
smooth_degree <- 2  ## Default smooth degree set to 2
FIND_PEAK <- "simple" # "xcms", "gc_auto_fit"
FIND_PA <- "trapz"   # "step", "trapz", "gc_auto_fit"
debug()
options(error = traceback)
index_to_peak_area <- list()
for (i in 1:length(ms)){
compound_chromatogram <- ms[i]
rt <- compound_chromatogram@rtime
if(smooth == FALSE){ ## By default, smooth = FALSE
intensity <- compound_chromatogram@intensity
}else{
lo <- stats::loess(intensity ~ rt, degree = smooth_degree) ## Add a namespace
intensity <- lo$fitted
}
# Get 'peakRange', including 'rt', 'rt_min', and 'rt_max'
if(FIND_PEAK == "simple"){
peakRange <- get_peak_range_simple(rt, intensity)
}else if(FIND_PEAK == "xcms"){
cent_wave_param <- xcms::CentWaveParam(snthresh = 2) ## Add a namespace
peakRange <- get_peak_range_on_xcms_find_peaks(compound_chromatogram, cent_wave_param)
}else if(FIND_PEAK == "gc_auto_fit"){
peakRange <- find_peak_range_gc_auto_fit(rt, intensity)
}
# Calculate the peak area
if(FIND_PA == "simple"){
peak_area <- get_peak_area_simple(rt, intensity, peakRange)
} else if(FIND_PA == "step"){
peak_area <- cal_peak_area_step(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "trapz"){
peak_area <- cal_peak_area_trapz(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "gc_auto_fit"){
peak_area <- find_peak_area_gc_auto_fit(rt, intensity, peakRange, peak.scanidx)
}
index_to_peak_area[[i]] <- list(peak_rt = peakRange$RT, peak_area = peak_area)
}
# Print the peak_area
df <- data.frame("rt", "peak_area")
for(i in 1:length(index_to_peak_area)){
df[nrow(df) + 1, ] = c(toString(round(index_to_peak_area[[i]]$peak_rt, 3)),
toString(round(index_to_peak_area[[i]]$peak_area), 0))
}
csv_file <- glue::glue("{base_file_name}.csv")
write.csv(df, csv_file, row.names = FALSE)
index_to_peak_area <- list()
for (i in 1:length(ms)){
compound_chromatogram <- ms[i]
rt <- compound_chromatogram@rtime
if(smooth == FALSE){ ## By default, smooth = FALSE
intensity <- compound_chromatogram@intensity
}else{
lo <- stats::loess(intensity ~ rt, degree = smooth_degree) ## Add a namespace
intensity <- lo$fitted
}
# Get 'peakRange', including 'rt', 'rt_min', and 'rt_max'
if(FIND_PEAK == "simple"){
peakRange <- get_peak_range_simple(rt, intensity)
}else if(FIND_PEAK == "xcms"){
cent_wave_param <- xcms::CentWaveParam(snthresh = 2) ## Add a namespace
peakRange <- get_peak_range_on_xcms_find_peaks(compound_chromatogram, cent_wave_param)
}else if(FIND_PEAK == "gc_auto_fit"){
peakRange <- find_peak_range_gc_auto_fit(rt, intensity)
}
# Calculate the peak area
browser()
if(FIND_PA == "simple"){
peak_area <- get_peak_area_simple(rt, intensity, peakRange)
} else if(FIND_PA == "step"){
peak_area <- cal_peak_area_step(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "trapz"){
peak_area <- cal_peak_area_trapz(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "gc_auto_fit"){
peak_area <- find_peak_area_gc_auto_fit(rt, intensity, peakRange, peak.scanidx)
}
index_to_peak_area[[i]] <- list(peak_rt = peakRange$RT, peak_area = peak_area)
}
if(FIND_PA == "simple"){
peak_area <- get_peak_area_simple(rt, intensity, peakRange)
} else if(FIND_PA == "step"){
peak_area <- cal_peak_area_step(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "trapz"){
peak_area <- cal_peak_area_trapz(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "gc_auto_fit"){
peak_area <- find_peak_area_gc_auto_fit(rt, intensity, peakRange, peak.scanidx)
}
print(peak.scanidx)
print(rt)
print(intensity)
print(peak.scanidx)
print(peakRange)
# 3 ways to find the peak: 1) "simple" (e.g. highest peak), 2) "xcms", and 3) "gc-auto_fit"
# 4 ways to calculate the peak area: 1) "simple" (e.g. peak_middle * peak_range);
# 2) "step"; 3) "trapz"; and 4) "gc-auto_fit"
# Choose the degree of smooth
# Benchmark through the mean absolute error (MAE)
smooth <- FALSE
smooth_degree <- 2  ## Default smooth degree set to 2
FIND_PEAK <- "simple" # "xcms", "gc_auto_fit"
FIND_PA <- "gc_auto_fit"   # "step", "trapz", "gc_auto_fit"
index_to_peak_area <- list()
for (i in 1:length(ms)){
compound_chromatogram <- ms[i]
rt <- compound_chromatogram@rtime
if(smooth == FALSE){ ## By default, smooth = FALSE
intensity <- compound_chromatogram@intensity
}else{
lo <- stats::loess(intensity ~ rt, degree = smooth_degree) ## Add a namespace
intensity <- lo$fitted
}
# Get 'peakRange', including 'rt', 'rt_min', and 'rt_max'
if(FIND_PEAK == "simple"){
peakRange <- get_peak_range_simple(rt, intensity)
}else if(FIND_PEAK == "xcms"){
cent_wave_param <- xcms::CentWaveParam(snthresh = 2) ## Add a namespace
peakRange <- get_peak_range_on_xcms_find_peaks(compound_chromatogram, cent_wave_param)
}else if(FIND_PEAK == "gc_auto_fit"){
peakRange <- find_peak_range_gc_auto_fit(rt, intensity)
}
if(FIND_PA == "simple"){
peak_area <- get_peak_area_simple(rt, intensity, peakRange)
} else if(FIND_PA == "step"){
peak_area <- cal_peak_area_step(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "trapz"){
peak_area <- cal_peak_area_trapz(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "gc_auto_fit"){
peak_area <- find_peak_area_gc_auto_fit(rt, intensity, peakRange, peak.scanidx)
}
index_to_peak_area[[i]] <- list(peak_rt = peakRange$RT, peak_area = peak_area)
}
# Print the peak_area
df <- data.frame("rt", "peak_area")
for(i in 1:length(index_to_peak_area)){
df[nrow(df) + 1, ] = c(toString(round(index_to_peak_area[[i]]$peak_rt, 3)),
toString(round(index_to_peak_area[[i]]$peak_area), 0))
}
csv_file <- glue::glue("{base_file_name}.csv")
write.csv(df, csv_file, row.names = FALSE)
index_to_peak_area <- list()
for (i in 1:length(ms)){
compound_chromatogram <- ms[i]
rt <- compound_chromatogram@rtime
if(smooth == FALSE){ ## By default, smooth = FALSE
intensity <- compound_chromatogram@intensity
}else{
lo <- stats::loess(intensity ~ rt, degree = smooth_degree) ## Add a namespace
intensity <- lo$fitted
}
# Get 'peakRange', including 'rt', 'rt_min', and 'rt_max'
if(FIND_PEAK == "simple"){
peakRange <- get_peak_range_simple(rt, intensity)
}else if(FIND_PEAK == "xcms"){
cent_wave_param <- xcms::CentWaveParam(snthresh = 2) ## Add a namespace
peakRange <- get_peak_range_on_xcms_find_peaks(compound_chromatogram, cent_wave_param)
}else if(FIND_PEAK == "gc_auto_fit"){
peakRange <- find_peak_range_gc_auto_fit(rt, intensity)
}
if(FIND_PA == "simple"){
peak_area <- get_peak_area_simple(rt, intensity, peakRange)
} else if(FIND_PA == "step"){
peak_area <- cal_peak_area_step(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "trapz"){
peak_area <- cal_peak_area_trapz(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "gc_auto_fit"){
peak_area <- find_peak_area_gc_auto_fit(rt, intensity, peakRange, peak.scanidx)
}
index_to_peak_area[[i]] <- list(peak_rt = peakRange$RT, peak_area = peak_area)
}
index_to_peak_area <- list()
for (i in 1:length(ms)){
compound_chromatogram <- ms[i]
rt <- compound_chromatogram@rtime
if(smooth == FALSE){ ## By default, smooth = FALSE
intensity <- compound_chromatogram@intensity
}else{
lo <- stats::loess(intensity ~ rt, degree = smooth_degree) ## Add a namespace
intensity <- lo$fitted
}
# Get 'peakRange', including 'rt', 'rt_min', and 'rt_max'
if(FIND_PEAK == "simple"){
peakRange <- get_peak_range_simple(rt, intensity)
}else if(FIND_PEAK == "xcms"){
cent_wave_param <- xcms::CentWaveParam(snthresh = 2) ## Add a namespace
peakRange <- get_peak_range_on_xcms_find_peaks(compound_chromatogram, cent_wave_param)
}else if(FIND_PEAK == "gc_auto_fit"){
peakRange <- find_peak_range_gc_auto_fit(rt, intensity)
}
browser()
if(FIND_PA == "simple"){
peak_area <- get_peak_area_simple(rt, intensity, peakRange)
} else if(FIND_PA == "step"){
peak_area <- cal_peak_area_step(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "trapz"){
peak_area <- cal_peak_area_trapz(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "gc_auto_fit"){
peak_area <- find_peak_area_gc_auto_fit(rt, intensity, peakRange, peak.scanidx)
}
index_to_peak_area[[i]] <- list(peak_rt = peakRange$RT, peak_area = peak_area)
}
print(peak.scanidx)
index_to_peak_area <- list()
for (i in 1:length(ms)){
browser()
compound_chromatogram <- ms[i]
rt <- compound_chromatogram@rtime
if(smooth == FALSE){ ## By default, smooth = FALSE
intensity <- compound_chromatogram@intensity
}else{
lo <- stats::loess(intensity ~ rt, degree = smooth_degree) ## Add a namespace
intensity <- lo$fitted
}
# Get 'peakRange', including 'rt', 'rt_min', and 'rt_max'
if(FIND_PEAK == "simple"){
peakRange <- get_peak_range_simple(rt, intensity)
}else if(FIND_PEAK == "xcms"){
cent_wave_param <- xcms::CentWaveParam(snthresh = 2) ## Add a namespace
peakRange <- get_peak_range_on_xcms_find_peaks(compound_chromatogram, cent_wave_param)
}else if(FIND_PEAK == "gc_auto_fit"){
peakRange <- find_peak_range_gc_auto_fit(rt, intensity)
}
browser()
if(FIND_PA == "simple"){
peak_area <- get_peak_area_simple(rt, intensity, peakRange)
} else if(FIND_PA == "step"){
peak_area <- cal_peak_area_step(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "trapz"){
peak_area <- cal_peak_area_trapz(rt, intensity, peakRange$RTmin, peakRange$RTmax)
} else if(FIND_PA == "gc_auto_fit"){
peak_area <- find_peak_area_gc_auto_fit(rt, intensity, peakRange, peak.scanidx)
}
index_to_peak_area[[i]] <- list(peak_rt = peakRange$RT, peak_area = peak_area)
}
n
?exit
library(xcms)
library(MSnbase) ## readSRMData() function
library(msdata)
library(pracma)
library(readxl)
# Source function file
setwd("~/lc-autofit")
# Load example data
base_file_name <- "KIT2-0-5404_1031350968_26_0_1_1_18_20000617-1031350968_1_1_18_20000617.mzML"
with_dir <- glue::glue("~/lc-autofit/lc-autofit-script/mzML/{base_file_name}")
ms <- MSnbase::readSRMData(files = with_dir)
# Define input variables (arguments)
length(ms)
compound_chromatogram <- ms[1]
rt <- compound_chromatogram@rtime
intensity <- compound_chromatogram@intensity
cent_wave_param <- xcms::CentWaveParam(snthresh = 2)
length(ms) ## Print
# Original function
get_peak_range_on_xcms_find_peaks <- function(chromatogram, cent_wave_param = CentWaveParam(snthresh = 2)) {
xchr <- findChromPeaks(chromatogram, param = cent_wave_param)
if(nrow(xchr@chromPeaks) == 0) {
return( list( RTmin=0, RT=0, RTmax=0 ))
}
suggested_row <- NULL
if(nrow(xchr@chromPeaks) > 1){
suggested_row <- 1
}else{
suggested_row <- 1
}
# class(xchr@chromPeaks) rt rtmin rtmax into intb maxo sn
# assume there are only one peak if found any
rt    <- xchr@chromPeaks[suggested_row,1]
rtmin <- xchr@chromPeaks[suggested_row,2]
rtmax <- xchr@chromPeaks[suggested_row,3]
return( list( RTmin=rtmin, RT=rt, RTmax=rtmax ) )
}
# Arguments
args(get_peak_range_on_xcms_find_peaks)
# Debug the original function
debug(get_peak_range_on_xcms_find_peaks)
get_peak_range_on_xcms_find_peaks(chromatogram = compound_chromatogram)
undebug(get_peak_range_on_xcms_find_peaks)
?findChromPeaks
# Debug the original function
debug(get_peak_range_on_xcms_find_peaks)
get_peak_range_on_xcms_find_peaks(chromatogram = compound_chromatogram)
Q
args(findChromPeaks)
# Debug xcms function
debug(findChromPeaks)
xchr <- findChromPeaks(chromatogram, param = cent_wave_param)
undebug(findChromPeaks)
# Updated function
get_peak_range_on_xcms_find_peaks2 <- function(chromatogram, cent_wave_param = CentWaveParam(snthresh = 2)) {
xchr <- findChromPeaks(chromatogram, param = cent_wave_param)
if(nrow(xchr@chromPeaks) == 0) {
return( list( RTmin=0, RT=0, RTmax=0 ))
}
suggested_row <- NULL
if(nrow(xchr@chromPeaks) > 1){   ## what does if loop do here?
suggested_row <- 1
}else{
suggested_row <- 1
}
# class(xchr@chromPeaks) rt rtmin rtmax into intb maxo sn
# assume there are only one peak if found any
rt    <- xchr@chromPeaks[suggested_row,1]
rtmin <- xchr@chromPeaks[suggested_row,2]
rtmax <- xchr@chromPeaks[suggested_row,3]
return( list( RTmin=rtmin, RT=rt, RTmax=rtmax ) )
}
undebug(findChromPeaks)
# Debug xcms function
debug(findChromPeaks)
findChromPeaks(chromatogram, param = cent_wave_param)
undebug(findChromPeaks)
args(CentWaveParam)
xchr <- findChromPeaks(chromatogram, param = cent_wave_param)
xchr <- xcms::findChromPeaks(chromatogram, param = cent_wave_param)
xchr <- xcms::findChromPeaks(compound_chromatogram, param = cent_wave_param)
head(chromPeaks(xchr))
cent_wave_param <- xcms::CentWaveParam(snthresh = 1)
xchr <- xcms::findChromPeaks(compound_chromatogram, param = cent_wave_param)
head(chromPeaks(xchr))
xchr <- xcms::findChromPeaks(compound_chromatogram, cent_wave_param = CentWaveParam(snthresh = 1))
head(chromPeaks(xchr))
xchr <- xcms::findChromPeaks(compound_chromatogram, CentWaveParam(snthresh = 1))
head(chromPeaks(xchr))
xchr <- xcms::findChromPeaks(compound_chromatogram, CentWaveParam(snthresh = 100))
head(chromPeaks(xchr))
cent_wave_param <- xcms::CentWaveParam(snthresh = 1)
cent_wave_param <- xcms::CentWaveParam(snthresh = 2)
# Define input variables (arguments)
compound_chromatogram <- ms[2]
rt <- compound_chromatogram@rtime
intensity <- compound_chromatogram@intensity
cent_wave_param <- xcms::CentWaveParam(snthresh = 2)
# Original function
get_peak_range_on_xcms_find_peaks <- function(chromatogram, cent_wave_param = CentWaveParam(snthresh = 2)) {
xchr <- findChromPeaks(chromatogram, param = cent_wave_param)
if(nrow(xchr@chromPeaks) == 0) {
return( list( RTmin=0, RT=0, RTmax=0 ))
}
suggested_row <- NULL
if(nrow(xchr@chromPeaks) > 1){
suggested_row <- 1
}else{
suggested_row <- 1
}
# class(xchr@chromPeaks) rt rtmin rtmax into intb maxo sn
# assume there are only one peak if found any
rt    <- xchr@chromPeaks[suggested_row,1]
rtmin <- xchr@chromPeaks[suggested_row,2]
rtmax <- xchr@chromPeaks[suggested_row,3]
return( list( RTmin=rtmin, RT=rt, RTmax=rtmax ) )
}
# Which arguments
args(get_peak_range_on_xcms_find_peaks)
# Debug the original function
debug(get_peak_range_on_xcms_find_peaks)
get_peak_range_on_xcms_find_peaks(chromatogram = compound_chromatogram)
sg <- 1:5
sg
profvis::profvis({get_peak_range_on_xcms_find_peaks(chromatogram = compound_chromatogram)})
undebug(get_peak_range_on_xcms_find_peaks)
profvis::profvis({get_peak_range_on_xcms_find_peaks(chromatogram = compound_chromatogram)})
vignette("rd")
library(roxygen2)
install.packages("roxygen2")
library(roxygen2)
vignette("roxygen2")
