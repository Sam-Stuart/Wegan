---
title: "metacoder_exampleAnalysis"
author: "Xin (David) Zhao"
date: "2023-05-02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Example analysis 

This R Markdown file demonstrate basic workflow to plot the heat tree using `metacoder` package. 

Develop the following R scripts by following the instruction step by step in the metacoder [website](https://grunwaldlab.github.io/metacoder_documentation/example.html)

### Reading data 

```{r, message=FALSE}

# install.packages("metacoder")
library(metacoder)
library(taxa)
library(tidyverse)
library(scales)

```

```{r}

# Load in the OTU table included in the metacoder package 
data("hmp_otus") 

# Abundance matrix included in metacoder package 
# head(hmp_otus) 

```
In `hmp_otus`, columns are samples and rows are OTUs. 

```{r}

# Load covariables dataset included in the metacoder package 
data("hmp_samples") 

# Load sample data table 
# head(hmp_samples)

```
In `hmp_samples`, columns are clinical variables and rows are samples. 


Process the abundance matrix and parse the taxonomic information in the mean time. 
```{r}

obj <- metacoder::parse_tax_data(hmp_otus,
                                 class_cols = "lineage", 
                                 class_sep = ";", 
                                 class_regex = "^(.+)_(.+)$", 
                                 class_key = c(tax_rank = "info", 
                                               tax_name = "taxon_name"))  

# Distribution of mixed taxonomic ranks 
# table(obj$data$class_data[ ,3]) 

# Extract taxoonmy names 
species_table <- obj$data$class_data 

# 1000 unique OTUs 
unique(species_table$input_index) %>% length()

# Create a table with rows representing unique OTU and columns taxonomy names 
species_table2 <- species_table %>%
    select(-c(4:5)) %>% 
    spread(tax_rank, taxon_id) 


```

```{r}

# View the obj, a taxmap object 
# print(obj) 

```

### Abundance matrix manipulation 
#### Remove low-abundance counts 

The low-abundance sequences might be the results of sequencing error, so typically we remove any counts/ OTUs with less than some number of reads. In this example analysis, set all counts with less than 5 reads to zero, overwriting the original table. 

```{r}

obj$data$tax_data <- metacoder::zero_low_counts(obj, 
                                                data = "tax_data", 
                                                min_count = 5)

```
Check OTUs that no longer contain any observations after setting low-abundance to zero. 

```{r}

no_reads <- base::rowSums(obj$data$tax_data[, hmp_samples$sample_id]) == 0 

# Print 211 OTUs that has zero reads 
sum(no_reads)

```

Remove 211 OTUs and their associated taxa with `filter_obs` from `taxa` package. 

```{r}

obj <- metacoder::filter_obs(obj, 
                             data = "tax_data",
                             !no_reads,
                             drop_taxa = TRUE) 

# print(obj)

```

#### Accounting for un-even sampling

In practice, some samples may have more reads than others due to imperfect sequencing technologies. Typically, people work with rarefied counts or proportions to try to avoid the possibility fo sampling depth biasing the results. 

Use the function `calc_obs_props` to divide each sample's counts by the total number of counts observed for each sample, resulting in a proportion.  

```{r process count data}

# Calculate proportions from observation counts 
obj$data$tax_data_prop <- metacoder::calc_obs_props(obj = obj, 
                                                    data = "tax_data",
                                                    cols = hmp_samples$sample_id) 

# Different OTU may have the same taxon ID 
# dim(obj$data$tax_data_prop)

# table(obj$data$tax_data_prop[,1]) 

# Extract OTU counts table from obj 
taxa_data_df <- obj$data$tax_data 

# Merge OTU count table with taxonomy data 
taxa_data_df1 <- taxa_data_df %>% 
    rownames_to_column("input_index") %>% 
    mutate(input_index = as.integer(input_index)) %>% 
    left_join(species_table2, by = "input_index")  

# Reshape table for the following plotting purpose 
taxa_data_df1_long <- taxa_data_df1 %>% 
    gather(key = "tax_rank", 
           value = "tax_name", 
           -c(1:54))  
```


#### Get per-taxon information 

To get information on the taxa, we sum the abundance per-taxon and add the results to the `taxmap` object in a new table. 

Use the newly created data-set, `tax_abund` for visualization of stacked bar plot and pie chart. 

```{r} 

# Sum observation values for each taxon 
obj$data$tax_abund <- metacoder::calc_taxon_abund(obj, # taxmap object 
                                                  "tax_data", # The table in obj$data 
                                                  cols = hmp_samples$sample_id) 

# 174 unique taxon IDs 
dim(obj$data$tax_abund)

```

Calculate the number of samples that have reads for each taxon. 

```{r}

# Count the number of samples 
obj$data$tax_occ <- metacoder::calc_n_samples(obj, # A taxmp object
                                              "tax_abund", 
                                              groups = hmp_samples$body_site, # Group columns per treatment/group
                                              cols = hmp_samples$sample_id) 


print(obj$data$tax_occ)

```

### Plot taxonomic tree (also known as heat tree)

The node below plots the number of "Nose" samples that have reads for each taxon as the size of each each taxon. It also plots the number of OTUs assigned to each taxon in the overall dataset as color. 
```{r}

set.seed(1) # This makes the plot appear the same every time it is generated 

metacoder::heat_tree(obj, # A taxmap object 
                     node_label = taxon_names, 
                     node_size = n_obs,
                     node_color = Nose, # Non-standard evaluation (NSE) 
                     node_size_axis_label = "OTU count",
                     node_color_axis_label = "Sample with reads",
                     layout = "davidson-harel", # The primary layout algorithm 
                     initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations 

```
#### Compare two treatments/ groups 

```{r, warning=FALSE}

obj$data$diff_table <- metacoder::compare_groups(obj,
                                                 data = "tax_abund",
                                                 cols = hmp_samples$sample_id, # What columns of samples data to use 
                                                 groups = hmp_samples$sex) # What category each sample is assigned to 

print(obj$data$diff_table)

```

Correct for multiple comparisons. 

```{r}

# FDR method 
obj$data$diff_table$wilcox_p_value <- p.adjust(obj$data$diff_table$wilcox_p_value, 
                                               method = "fdr")

# View the distribution of p-values 
range(obj$data$diff_table$wilcox_p_value, finite = TRUE)

```
There is no significant difference. 


For each taxon, a Wilcoxon Rank Sum test was used to test for difference between the median abundances of samples in each treatment. We use this information to create what we call a differential heat tree, which indicates which taxa are more abundant in each treatment. 

```{r}

set.seed(999) 
metacoder::heat_tree(obj,
                     node_label = taxon_names,
                     node_size = n_obs, # n_obs in a function that calculates the number of OTUs per taxon 
                     node_color = log2_median_ratio, # A column from 'obj$data$diff_table' 
                     node_color_interval = c(-2, 2), # The range of 'log2_median_ratio' to display 
                     node_color_range = c("cyan", "gray", "tan"), # The color palette used 
                     node_size_axis_label = "OTU count",
                     node_color_axis_label = "Log 2 ratio of median proportion",
                     layout = "davidson-harel", # The primary layout algorithm
                     initial_layout = "reingold-tilford") # The layout algorithm 

```

#### Compare multiple treatments/ groups 

To compare more than two groups, we can make a matrix of heat trees, one for each pairwise comparison of treatments 

```{r, warning=FALSE}

obj$data$diff_table <- metacoder::compare_groups(obj,
                                                 data = "tax_abund",
                                                 cols = hmp_samples$sample_id,
                                                 groups = hmp_samples$body_site) # What category each sample is assigned to


print(obj$data$diff_table)

```

A special function `heat_tree_matrix` to plot this type of data 

```{r} 

set.seed(1) 

metacoder::heat_tree_matrix(obj,
                            data = "diff_table",
                            node_size = n_obs,
                            node_label = taxon_names,
                            node_color = log2_median_ratio,
                            node_color_range = diverging_palette(),
                            node_color_trans = "linear",
                            node_color_interval = c(-3, 3),
                            edge_color_interval = c(-3, 3),
                            node_size_axis_label = "Number of OTUs",
                            node_color_axis_label = "Log2 ratio median proportions",
                            layout = "davidson-harel",
                            initial_layout = "reingold-tilford",
                            output_file = "./Phylogeny_output.pdf") 


```
The grey tree on the lower left functions as a key for the unlabeled trees.


#### Pie chart at the specified taxonomic rank 

Prepare data sets for plotting with ggplot2 

```{r}
# Data sets included in obj 
names(obj$data)


# Extract tax_abund (proportion per taxon) 
countPerTaxon <- obj$data$tax_abund 

colSums(countPerTaxon[,-1]) # Sum by columns 

# Merge taxonomy rank table with the above data table by the column, taxon_id 
taxaRank <- obj$data$class_data 
taxaRank_distinct <- distinct(taxaRank, taxon_id, .keep_all = TRUE) 

countPerTaxon_Rank <- countPerTaxon %>% 
    dplyr::left_join(taxaRank_distinct, 
                     by = "taxon_id") %>% 
    select(-input_index)

dim(countPerTaxon_Rank) 

head(countPerTaxon_Rank)

countPerTaxon_Rank_long <- countPerTaxon_Rank %>% 
    gather(key = "sample_id", value = "counts", -taxon_id) %>% 
    inner_join(hmp_samples, by = "sample_id") 

# Pie chart: proportion based on counts per taxon by env groups 
stat_countPerTaxa_byGroup <- countPerTaxon_Rank_long %>% 
    mutate(counts = as.numeric(counts)) %>% 
    group_by(sex, taxon_id) %>% 
    summarise(counts = sum(counts), .groups = "drop") 

stat_countPerTaxa_byGroup2 <- stat_countPerTaxa_byGroup %>% 
                                                group_by(sex) %>% 
                                                summarise(total_by_group = sum(counts))  

stat_countPerTaxa_byGroup3 <- stat_countPerTaxa_byGroup %>% 
    left_join(stat_countPerTaxa_byGroup2, 
              by = "sex") %>% 
    mutate(prop =  counts/ total_by_group) # Calculate relative abundance 

stat_countPerTaxa_byGroup4 <- stat_countPerTaxa_byGroup3 %>% 
    left_join(taxaRank_distinct, by = "taxon_id")

# # Subset phylum level 
# phylumByGroup <- stat_countPerTaxa_byGroup4 %>% 
#     filter(tax_rank == "p_")


```

Create the pie chart with ggplot2 

```{r pie chart}
# Customize legend labels 
breaks <- phylumByGroup %>% 
    filter(sex == "female") %>% 
    pull(taxon_id)
    
labels <- phylumByGroup %>% 
    filter(sex == "female") %>% 
    pull(tax_name)

ggplot(phylumByGroup, 
       aes(x = "", y = prop, fill = taxon_id)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) + 
    scale_fill_discrete(name = "Taxonomy",
                         breaks = breaks,
                         labels = labels) + 
    facet_grid(cols = vars(sex)) + 
    theme_void()

```

#### Stacked bar plot 

First, reproduce the above pie chart with stacked bar plot. 

```{r stacked bar plot}

# Subset phylum level, and add up count per taxon (instead of per sample)
phylum_sumCount <- taxa_data_df1_long %>% 
    dplyr::filter(tax_rank == "p_") %>% 
    gather(key = "sample_id", 
           value = "count", 
           -c(1:4, 55:56)) %>% 
    group_by(sample_id, # Aggregate counts per taxon 
             tax_name) %>% 
    summarise(count_perTaxon =  sum(count), 
              .groups = "drop") 


# Merge the above table with environmental variables by sample_id 
phylum_sumCount2 <- phylum_sumCount %>% 
    left_join(hmp_samples, by = "sample_id") 
    
phylum_sumCount3 <- phylum_sumCount2 %>% 
    mutate(sex = str_replace(sex, "^male", "Male")) %>%  # Replace male with Male 
    mutate(sex = str_replace(sex, "female", "Female")) %>% # Replace Female with female 
    filter(!is.na(tax_name)) 
    
topTaxon <- phylum_sumCount3 %>% 
    group_by(tax_name) %>% 
    summarise(averageCount = ave(count_perTaxon),
              .groups = "drop") %>%
    arrange(desc(averageCount)) %>% 
    distinct(tax_name, .keep_all = T) %>% 
    head(1) %>% # the top taxon with the most average counts across samples 
    pull(tax_name)

# Extract re-ordered taxa names 
taxa_oder <- phylum_sumCount3 %>% 
    group_by(tax_name) %>% 
    summarise(averageCount = ave(count_perTaxon),
              .groups = "drop") %>%
    arrange(desc(averageCount)) %>% 
    distinct(tax_name, .keep_all = TRUE) %>% 
    filter(!is.na(tax_name)) %>% 
    pull(tax_name)

# Reorder sample_id by counts of "af" 
afCount_df <- phylum_sumCount3 %>% 
    filter(tax_name == "af") %>% 
    select(sample_id, af_count = count_perTaxon) 

# Descending order 
phylum_sumCount4 <- phylum_sumCount3 %>% 
    left_join(afCount_df, by = "sample_id") %>% 
    arrange(desc(af_count)) 

# Extract re-ordered sample_id 
level_order <- phylum_sumCount4 %>% 
    group_by(sample_id) %>% 
    summarise(af_perc = af_count/sum(count_perTaxon), .groups = "drop") %>% 
    distinct(sample_id, .keep_all = TRUE)  %>%
    arrange(desc(af_perc)) %>%
    pull(sample_id)

# Re-order stacking element in each bar 
phylum_sumCount3$tax_name <- factor(phylum_sumCount3$tax_name,
                                     levels = taxa_oder) 


# Stacked bar plot at phylum level with percentage labels 
stackBarPlot<- ggplot(phylum_sumCount3, 
       aes(x = factor(sample_id, level = level_order),
           y = count_perTaxon, # Use count as y-values 
           fill = tax_name)) +
    geom_bar(position = "fill", # Stack elements and normalize height
             stat = "identity") + # Tell ggplot2 the y-values
    facet_wrap(vars(sex),
               dir = "h",
               labeller = label_value, 
               scales = "free_x") +  # Facet samples by environmental factor 
    theme(axis.text.x = element_blank(),
          axis.ticks = element_blank()) 

stackBarPlot # Print ggplot 


# Change legend labels 
# names(species_table) 

legendTax_df <- species_table %>% 
    filter(taxon_id %in% taxa_oder) %>% 
    distinct(taxon_id, .keep_all = TRUE) # Drop repeated names 

legendTax_df2 <- legendTax_df[match(legendTax_df$taxon_id, taxa_oder), ] 

# Extract legend values 
legendVal <- taxa_oder 

# Extract legend labels mapping to the above values 
legendLab <- legendTax_df2$tax_name 


# Modify the legend 
stackBarPlot1 <- stackBarPlot +
    scale_fill_discrete(breaks = c(legendVal),
                        labels = c(legendLab)) +
    labs(fill = "") +
    theme(legend.position="bottom",
          # legend.title = element_text(color = "black", size = 10),
          legend.text = element_text(color = "black", size = 8),
          panel.background = element_rect(fill = "white"), # Panel background 
          axis.ticks.y = element_line(linewidth = 0.3)) + # y-axis tick width 
    xlab("") +
    ylab("") +
    scale_y_continuous(labels = scales::percent)  # Axis label include % sign
    
stackBarPlot1 # Print plot

# Export ggplot 
ggsave("./ggPlotStackBarPlot_phylumLevel.pdf", stackBarPlot1,
       device = "pdf",
       width = 12,
       height = 8,
       units = "in") 

```

Secondly, show fine distribution of taxa per sample at specified taxonomic rank; gather samples by environmental groupings, such as sex and body sites. This visualization looks elegant only if number of samples is reasonable; otherwise visualization gets messy. 

```{r}






```






















