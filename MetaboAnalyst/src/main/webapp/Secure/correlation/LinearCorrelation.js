/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/JSP_Servlet/JavaScript.js to edit this template
 */

var URL = document.getElementById("mydir").value;

var margin = { top: 30, right: 30, bottom: 50, left: 60 },
    width = 480 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;
/**
 *
 * @param {*} id The id of the div that we want to plot in
 * @returns a graph object (g) generated by D3
 */
function createSVG(id) {
    return d3
        .select(`#${id}`)
        .classed("plot_container", true)
        .append("svg")
        .classed("svg", true)
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
}

/**
 *
 * @param {*} data Data read from JSON
 * @returns An object that contains information for plotting
 */
function extractData(data) {
    const [xLabel, yLabel] = data.axis;
    const equation = `${yLabel} = ${data.slope} * ${xLabel} + ${data.yint}`;

    return {
        title: data.main,
        xLabel,
        yLabel,
        point_coords: data.points.coords,
        line_coords: data.lines.coords,
        CI: data.lines.ci,
        equationInfo: {
            equation,
            Rsquare: data.r_sq,
            RsquareAdjusted: data.r_sq_adj,
        },
        showLabel: {
            CI: data.bool_ci,
            equation: data.bool_eq,
            rSquare: data.bool_rsq,
            rSquareAdjusted: data.bool_rsq_adj,
        },
        slope: data.slope,
        yint: data.yint,
    };
}

/**
 *
 * @param {*} id Id of the div we want to plot in
 * @param {*} scatter the scatter layer that controls zoom and drag
 * @param {*} zoom zoom object created by D3
 * @returns An array of navigation buttons
 */
function createNavigationButtons(id, scatter, zoom) {
    // Navigation using buttons: Supports zoom and pan
    const navigationButtons = d3
        .select(`#${id}`)
        .append("div")
        .classed("navigation_buttons_container", true);

    const resetButton = navigationButtons
        .append("button")
        .classed("navigation-buttons", true)
        .attr("type", "button")
        .on("click", function () {
            scatter
                .transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity);
        });
    resetButton
        .append("i")
        .classed("fa fa-refresh", true)
        .attr("aria-hidden", "true");
    //Pan Buttons
    const moveDuration = 500;

    function createPanButton(iconName, translateX, translateY) {
        const button = navigationButtons
            .append("button")
            .classed("navigation-buttons", true)
            .attr("type", "button")
            .on("click", function () {
                scatter
                    .transition()
                    .duration(moveDuration)
                    .call(zoom.translateBy, translateX, translateY);
            });
        button
            .append("i")
            .classed(`fa ${iconName}`, true)
            .attr("aria-hidden", "true");

        return button;
    }

    const panRightButton = createPanButton("fa-arrow-left", 50, 0);
    const panUpButton = createPanButton("fa-arrow-up", 0, 50);
    const panDownButton = createPanButton("fa-arrow-down", 0, -50);
    const panLeftButton = createPanButton("fa-arrow-right", -50, 0);

    // Zoom buttons
    function createZoomButton(iconName, fraction) {
        const button = navigationButtons
            .append("button")
            .classed("navigation-buttons", true)
            .attr("type", "button")
            .on("click", function () {
                scatter
                    .transition()
                    .duration(moveDuration)
                    .call(zoom.scaleBy, fraction);
            });

        button
            .append("i")
            .classed(`fa ${iconName}`, true)
            .attr("aria-hidden", "true");
    }

    const zoomInButton = createZoomButton("fa-search-plus", 2);
    const zoomOutButton = createZoomButton("fa-search-minus", 0.5);

    return [
        navigationButtons,
        zoomInButton,
        zoomOutButton,
        panUpButton,
        panDownButton,
        panLeftButton,
        panRightButton,
        resetButton,
    ];
}

/**
 *
 * @param {*} svg The root svg
 * @param {*} id id of the div we want to plot in
 * @param {*} updateChart function to be called when zoom or pan is triggered
 * @returns {Object} Scatter, which is a square on top op the graph to capture user mouse and zoom created by D3
 */
function makeGraphZoomable(svg, id, updateChart) {
    // Add a clipPath: everything out of this area won't be drawn.
    svg.append("defs")
        .append("SVG:clipPath")
        .attr("id", "clip" + id)
        .append("SVG:rect")
        .attr("width", width)
        .attr("height", height)
        .attr("x", 0)
        .attr("y", 0);

    // Create the scatter variable: where both the circles and the brush take place
    var scatter = svg.append("g").attr("clip-path", `url(#clip${id})`);

    // Set the zoom and Pan features: how much you can zoom, on which part, and what to do when there is a zoom
    var zoom = d3
        .zoom()
        .scaleExtent([0.5, 20]) // This control how much you can unzoom (x0.5) and zoom (x20)
        .extent([
            [0, 0],
            [width, height],
        ])
        .on("zoom", updateChart);

    // This add an invisible rect on top of the chart area. This rect can recover pointer events: necessary to understand when the user zoom
    scatter
        .append("rect")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "none")
        .style("pointer-events", "all")
        .lower();

    scatter.call(zoom);
    // now the user can zoom and it will trigger the function called updateChart

    return { scatter, zoom };
}

/**
 *
 * @param {*} id id of the div we want to plot in
 * @param {*} title title of the th graph
 */
function createTitle(id, title) {
    d3.select(`#${id}_title`).classed("plot_title", true).html(title);
}

/** */
function plotPoints(scatter, values, tooltip, xScale, yScale) {
    return scatter
        .selectAll("circle")
        .data(values)
        .enter()
        .append("circle")
        .attr("id", "mypoint")
        .attr("x-value", function (d) {
            return d.x;
        })
        .attr("y-value", function (d) {
            return d.y;
        })
        .attr("cx", function (d) {
            return xScale(d.x);
        })
        .attr("cy", function (d) {
            return yScale(d.y);
        })
        .attr("r", 4)
        .style("fill", (d) => d.color)
        .on("mouseover", function (d) {
            tooltip
                .style("opacity", 0.8)
                .html("(" + d.x + ", " + d.y + ")")
                .style("left", event.pageX + 5 + "px")
                .style("top", event.pageY + "px");
        })
        .on("mouseout", function (d) {
            tooltip.transition(200).style("opacity", 0);
        });
}

function addToolTip(id) {
    return d3
        .select("body")
        .append("div")
        .attr("id", "tooltip" + id)
        .attr("class", "tooltip_viz")
        .style("opacity", 0)
        .style("position", "absolute");
}

function plotLine(scatter, line_values, line, strokeColor) {
    return scatter
        .append("path")
        .datum(line_values)
        .attr("class", "line")
        .attr("d", line)
        .style("stroke", strokeColor);
}

function renderEquation(
    svg,
    showLabel,
    { equation, Rsquare, RsquareAdjusted }
) {
    var equationGroup = svg.append("g").classed("equation", true);

    if (showLabel.equation) equationGroup.append("text").text(equation);

    if (showLabel.rSquare)
        equationGroup
            .append("text")
            .text(`R Square = ${Rsquare}`)
            .attr("y", 15)
            .attr("x", width / 2);

    if (showLabel.rSquareAdjusted)
        equationGroup
            .append("text")
            .text(`R Square Adjusted = ${RsquareAdjusted}`)
            .attr("y", 30)
            .attr("x", width / 2);
}

/**
 *
 * @param {*} jsonName Name of the json file
 * @param {*} id id of the div that we want to plot in
 */
function renderLinearBestFit(jsonName, id) {
    //Read the data
    d3.json("/MetaboAnalyst" + URL + "/" + jsonName, function (data) {
        //Create and styling SVG
        var svg = createSVG(id);
        //Extract data
        const {
            title,
            xLabel,
            yLabel,
            point_coords,
            line_coords,
            CI,
            equationInfo,
            showLabel,
        } = extractData(data);

        //This will be used to draw the line and the confidence interval
        const line_values = line_coords.x.map((e, i) => ({
            x: +e,
            y: +line_coords.y[i],
            CI_down: +CI.CI_down[i],
            CI_up: +CI.CI_up[i],
        }));

        //Create an array of objects of points
        const values = point_coords.x.map((e, i) => ({
            x: +e,
            y: +point_coords.y[i],
            color: data.points.cols[i],
        }));

        //Define Xaxis, add xAxis and xAxis label
        const xScale = d3
            .scaleLinear()
            .domain(d3.extent(values, (d) => d.x))
            .range([0, width]);
        var xAxis = svg
            .append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(xScale));

        svg.append("text")
            .text(xLabel)
            .attr("x", width / 3)
            .attr("y", height + 30)
            .style("font-size", "15px");

        // Add Y axis, add yAxis and yAxis label
        var yScale = d3
            .scaleLinear()
            .domain(d3.extent(values, (d) => d.y))
            .range([height, 0]);
        var yAxis = svg.append("g").call(d3.axisLeft(yScale));

        svg.append("text")
            .text(yLabel)
            .attr("y", -30)
            .attr("x", -(height / 3))
            .style("text-anchor", "end")
            .attr("transform", "rotate(-90)")
            .style("margin-bottom", "10px")
            .style("font-size", "15px");

        //Create line
        var line = d3
            .line()
            .x(function (d) {
                return xScale(d.x);
            })
            .y(function (d) {
                return yScale(d.y);
            });

        //Set up zoom and scatter
        const { scatter, zoom } = makeGraphZoomable(svg, id, updateChart);

        // A function that updates the chart when the user zoom and thus new boundaries are available
        function updateChart() {
            // recover the new scale
            var newX = d3.event.transform.rescaleX(xScale);
            var newY = d3.event.transform.rescaleY(yScale);

            // update axes with these new boundaries
            xAxis.call(d3.axisBottom(newX));
            yAxis.call(d3.axisLeft(newY));

            // update circle position
            scatter
                .selectAll("circle")
                .attr("cx", function (d) {
                    return newX(d.x);
                })
                .attr("cy", function (d) {
                    return newY(d.y);
                });

            scatter.select(".line").attr(
                "d",
                d3
                    .line()
                    .x((d) => newX(d.x))
                    .y((d) => newY(d.y))
            );

            scatter.select(".confidence_interval").attr(
                "d",
                d3
                    .area()
                    .x(function (d) {
                        return newX(d.x);
                    })
                    .y0(function (d) {
                        return newY(d.CI_up);
                    })
                    .y1(function (d) {
                        return newY(d.CI_down);
                    })
            );
        }

        // Appennd confidence interval
        if (showLabel.CI)
            scatter
                .append("path")
                .classed("confidence_interval", true)
                .datum(line_values)
                .attr("fill", "#CBCBCB")
                .attr("stroke", "none")
                .attr(
                    "d",
                    d3
                        .area()
                        .x(function (d) {
                            return xScale(d.x);
                        })
                        .y0(function (d) {
                            return yScale(d.CI_up);
                        })
                        .y1(function (d) {
                            return yScale(d.CI_down);
                        })
                );

        //Tool tip
        const tooltip = addToolTip(id);

        // Add dots
        plotPoints(scatter, values, tooltip, xScale, yScale);

        // Append line
        const lineOnPlot = plotLine(
            scatter,
            line_values,
            line,
            data.lines.cols[0]
        );
        lineOnPlot
            .on("mouseover", function (d) {
                tooltip
                    .style("opacity", 0.8)
                    .html(equationInfo.equation)
                    .style("left", event.pageX + 5 + "px")
                    .style("top", event.pageY + "px");
            })
            .on("mouseout", function (d) {
                tooltip.transition(200).style("opacity", 0);
            });

        // create title
        createTitle(id, title);

        // Equation;
        renderEquation(svg, showLabel, equationInfo);

        // Navigation using buttons: Supports zoom and pan
        //Get only the first element in array: const [first] = [1,2,3];
        createNavigationButtons(id, scatter, zoom);
    });
}

function renderNormalityPlot(jsonName, id) {
    d3.json("/MetaboAnalyst" + URL + "/" + jsonName, function (data) {
        //Create and styling SVG
        var svg = createSVG(id);

        //Extract data
        const {
            title,
            xLabel,
            yLabel,
            point_coords,
            slope,
            yint,
            equationInfo,
        } = extractData(data);

        //Generate y from x using euqation
        function calculateYfromEquation(m, yint, x) {
            return m * x + yint;
        }

        //Create an array of objects of points
        const values = point_coords.x.map((e, i) => ({
            x: +e,
            y: +point_coords.y[i],
            color: data.points.cols[i],
        }));

        //Create an array of objects of line's coordinates
        const line_values = point_coords.x.map((e) => ({
            x: +e,
            y: +calculateYfromEquation(slope, yint, e),
        }));

        //Create line
        const line = d3
            .line()
            .x(function (d) {
                return xScale(d.x);
            })
            .y(function (d) {
                return yScale(d.y);
            });

        //Define Xaxis, add xAxis and xAxis label
        const xScale = d3
            .scaleLinear()
            .domain(d3.extent(values, (d) => d.x))
            .range([0, width]);
        var xAxis = svg
            .append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(xScale));

        svg.append("text")
            .text(xLabel)
            .attr("x", width / 3)
            .attr("y", height + 30)
            .style("font-size", "15px");

        // Add Y axis, add yAxis and yAxis label
        const yScale = d3
            .scaleLinear()
            .domain(d3.extent(values, (d) => d.y))
            .range([height, 0]);
        var yAxis = svg.append("g").call(d3.axisLeft(yScale));

        svg.append("text")
            .text(yLabel)
            .attr("y", -30)
            .attr("x", -(height / 3))
            .style("text-anchor", "end")
            .attr("transform", "rotate(-90)")
            .style("margin-bottom", "10px")
            .style("font-size", "15px");

        //Set up zoom and scatter
        const { scatter, zoom } = makeGraphZoomable(svg, id, updateChart);

        // A function that updates the chart when the user zoom and thus new boundaries are available
        function updateChart() {
            // recover the new scale
            var newX = d3.event.transform.rescaleX(xScale);
            var newY = d3.event.transform.rescaleY(yScale);

            // update axes with these new boundaries
            xAxis.call(d3.axisBottom(newX));
            yAxis.call(d3.axisLeft(newY));

            // update circle position
            scatter
                .selectAll("circle")
                .attr("cx", function (d) {
                    return newX(d.x);
                })
                .attr("cy", function (d) {
                    return newY(d.y);
                });

            //Update line
            scatter.select(".line").attr(
                "d",
                d3
                    .line()
                    .x((d) => newX(d.x))
                    .y((d) => newY(d.y))
            );
        }

        //Tool tip
        const tooltip = addToolTip(id);

        // Add dots
        plotPoints(scatter, values, tooltip, xScale, yScale);

        // Append line
        const lineOnPlot = plotLine(
            scatter,
            line_values,
            line,
            data.lines.cols
        );
        lineOnPlot
            .on("mouseover", function (d) {
                tooltip
                    .style("opacity", 0.8)
                    .html(equationInfo.equation)
                    .style("left", event.pageX + 5 + "px")
                    .style("top", event.pageY + "px");
            })
            .on("mouseout", function (d) {
                tooltip.transition(200).style("opacity", 0);
            });

        // create title
        createTitle(id, title);

        // Navigation using buttons: Supports zoom and pan
        //Get only the first element in array: const [first] = [1,2,3];
        createNavigationButtons(id, scatter, zoom);
    });
}

function renderResFitPlot(jsonName, id) {
    d3.json("/MetaboAnalyst" + URL + "/" + jsonName, function (data) {
        //Create and styling SVG
        var svg = createSVG(id);
        //Extract data
        const {
            title,
            xLabel,
            yLabel,
            point_coords,
            line_coords,
            equationInfo,
            showLabel,
        } = extractData(data);

        //This will be used to draw the line and the confidence interval
        const line_values = line_coords.x.map((e, i) => ({
            x: +e,
            y: +line_coords.y[i],
        }));

        //Create an array of objects of points
        const values = point_coords.x.map((e, i) => ({
            x: +e,
            y: +point_coords.y[i],
            color: data.points.cols[i],
        }));

        //Define Xaxis, add xAxis and xAxis label
        const xScale = d3
            .scaleLinear()
            .domain(d3.extent(values, (d) => d.x))
            .range([0, width]);
        var xAxis = svg
            .append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(xScale));

        svg.append("text")
            .text(xLabel)
            .attr("x", width / 3)
            .attr("y", height + 30)
            .style("font-size", "15px");

        // Add Y axis, add yAxis and yAxis label
        var yScale = d3
            .scaleLinear()
            .domain(d3.extent(values, (d) => d.y))
            .range([height, 0]);
        var yAxis = svg.append("g").call(d3.axisLeft(yScale));

        svg.append("text")
            .text(yLabel)
            .attr("y", -30)
            .attr("x", -(height / 3))
            .style("text-anchor", "end")
            .attr("transform", "rotate(-90)")
            .style("margin-bottom", "10px")
            .style("font-size", "15px");

        //Create line
        var line = d3
            .line()
            .x(function (d) {
                return xScale(d.x);
            })
            .y(function (d) {
                return yScale(d.y);
            });

        //Set up zoom and scatter
        const { scatter, zoom } = makeGraphZoomable(svg, id, updateChart);

        // A function that updates the chart when the user zoom and thus new boundaries are available
        function updateChart() {
            // recover the new scale
            var newX = d3.event.transform.rescaleX(xScale);
            var newY = d3.event.transform.rescaleY(yScale);

            // update axes with these new boundaries
            xAxis.call(d3.axisBottom(newX));
            yAxis.call(d3.axisLeft(newY));

            // update circle position
            scatter
                .selectAll("circle")
                .attr("cx", function (d) {
                    return newX(d.x);
                })
                .attr("cy", function (d) {
                    return newY(d.y);
                });

            scatter.selectAll(".line").attr(
                "d",
                d3
                    .line()
                    .x((d) => newX(d.x))
                    .y((d) => newY(d.y))
            );
        }

        //Tool tip
        const tooltip = addToolTip(id);

        // Add dots
        plotPoints(scatter, values, tooltip, xScale, yScale);

        // Append line
        const lineOnPlot = plotLine(
            scatter,
            line_values,
            line,
            data.lines.cols[0]
        );
        lineOnPlot
            .on("mouseover", function (d) {
                tooltip
                    .style("opacity", 0.8)
                    .html(equationInfo.equation)
                    .style("left", event.pageX + 5 + "px")
                    .style("top", event.pageY + "px");
            })
            .on("mouseout", function (d) {
                tooltip.transition(200).style("opacity", 0);
            });
        //Create horizontal line
        const line2OnPlot = plotLine(
            scatter,
            [
                { x: line_values[0].x, y: 0 },
                { x: line_values[line_values.length - 1].x, y: 0 },
            ],
            line,
            data.lines2.cols
        );

        line2OnPlot.style("stroke-width", "1.5");
        // create title
        createTitle(id, title);

        // Navigation using buttons: Supports zoom and pan
        //Get only the first element in array: const [first] = [1,2,3];
        createNavigationButtons(id, scatter, zoom);
    });
}

renderLinearBestFit("corr_linear.json", "my_dataviz");
renderLinearBestFit("corr_linear_pred.json", "my_dataviz1");
renderNormalityPlot("corr_linear_normres.json", "my_dataviz2");
renderResFitPlot("corr_linear_resfit.json", "my_dataviz3");
